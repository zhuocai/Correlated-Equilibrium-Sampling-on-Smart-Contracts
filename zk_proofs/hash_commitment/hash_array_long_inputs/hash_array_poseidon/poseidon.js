
import assert from "assert";
import { getCurveFromName }  from "ffjavascript";

import poseidonConstants from "./poseidon_constants.js";

function unsringifyConstants(Fr, o) {
    if ((typeof(o) == "string") && (/^[0-9]+$/.test(o) ))  {
        return Fr.e(o);
    } else if ((typeof(o) == "string") && (/^0x[0-9a-fA-F]+$/.test(o) ))  {
        return Fr.e(o);
    } else if (Array.isArray(o)) {
        return o.map(unsringifyConstants.bind(null, Fr));
    } else if (typeof o == "object") {
        if (o===null) return null;
        const res = {};
        const keys = Object.keys(o);
        keys.forEach( (k) => {
            res[k] = unsringifyConstants(Fr, o[k]);
        });
        return res;
    } else {
        return o;
    }
}


function poseidon(inputs, initState, nOut, bn128, F, C, M, N_ROUNDS_F, N_ROUNDS_P, pow5) {
    assert(inputs.length > 0);
    assert(inputs.length <= N_ROUNDS_P.length);

    const t = inputs.length + 1;
    const nRoundsF = N_ROUNDS_F;
    const nRoundsP = N_ROUNDS_P[t - 2];

    if (initState) {
        initState = F.e(initState);
    } else {
        initState = F.zero;
    }
    nOut = nOut || 1;

    let state = [initState, ...inputs.map(a => F.e(a))];
    for (let r = 0; r < nRoundsF + nRoundsP; r++) {
        state = state.map((a, i) => F.add(a, C[t - 2][r * t + i]));

        if (r < nRoundsF / 2 || r >= nRoundsF / 2 + nRoundsP) {
            state = state.map(a => pow5(a));
        } else {
            state[0] = pow5(state[0]);
        }

        state = state.map((_, i) =>
            state.reduce((acc, a, j) => F.add(acc, F.mul(M[t - 2][i][j], a)), F.zero)
        );
    }
    if (nOut == 1) {
        return state[0]
    } else {
        return state.slice(0, nOut);
    }
}



export default async function buildPoseidon_ex() {

    const bn128 = await getCurveFromName("bn128", true);

    const F = bn128.Fr;

    // Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
    // Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
    const {C, M} = unsringifyConstants(F, poseidonConstants);

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    const N_ROUNDS_F = 8;
    const N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];

    const pow5 = a => F.mul(a, F.square(F.square(a, a)));

    function poseidon_ex(inputs, initState, nOut) {
        let poseidon_out;
        let poseidon_out_add;

        for (var i=0; i<inputs.length; i+=16) {
            
            if (i==0) {
                // console.log("i=",i);
                // console.log("inputs [0, 16]", inputs.slice(i, i+16));

                // for (var j=0; j<16; j++) {
                //     console.log(poseidon_ex.F.toString(inputs[j], 16));
                // }

                poseidon_out = poseidon(inputs.slice(i, i+16), initState, 16, bn128, F, C, M, N_ROUNDS_F, N_ROUNDS_P, pow5);
                
                // for (var j=0; j<16; j++) {
                //     console.log(poseidon_ex.F.toString(poseidon_out[j], 16));
                // }
                
            }
            else if (i==inputs.length-16) {
                poseidon_out = poseidon(poseidon_out_add, initState, nOut, bn128, F, C, M, N_ROUNDS_F, N_ROUNDS_P, pow5);
                
                // for (var j=0; j<16; j++) {
                //     // console.log(poseidon_out_add[j]);
                //     console.log(poseidon_ex.F.toString(poseidon_out_add[j], 16));
                // }
                return poseidon_out;
            }
            else {
                poseidon_out = poseidon(poseidon_out_add, initState, 16, bn128, F, C, M, N_ROUNDS_F, N_ROUNDS_P, pow5);
            }


            poseidon_out_add = new Array(16);
            for (var j=0, k=i+16; j<16; j++, k++) {
                poseidon_out_add[j] = F.add(poseidon_out[j], poseidon_ex.F.e(inputs[k]));
                // console.log(poseidon_out[j]);
                // console.log(poseidon_ex.F.e(inputs[k]));
                
                // console.log(poseidon_ex.F.toString(poseidon_out_add[j], 16));
            }
        }

        return poseidon_out;
    }
    poseidon_ex.F = F;
    return poseidon_ex;

}

let poseidon_ex = await buildPoseidon_ex();
// const res1 = poseidon_ex([1, 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 0, 1);
const res2 = poseidon_ex([1,2],0,1);
// console.log(res1);
// console.log(poseidon_ex.F.e("0x3049adcf4e032266b43632de3568e7c4b4e5a51414813d5c64fb32aa6783f12b"));
// console.log(poseidon_ex.F.toString(res1, 16));
console.log(poseidon_ex.F.toString(res2, 16));
// var view = new DataView(res1.buffer, 0);
// view.getUint32(0, true); 
// console.log(view.getUint32(0, true));