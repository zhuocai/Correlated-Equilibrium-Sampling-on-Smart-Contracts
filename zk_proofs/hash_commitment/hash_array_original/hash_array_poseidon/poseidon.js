
import assert from "assert";
import { getCurveFromName }  from "ffjavascript";

import poseidonConstants from "./poseidon_constants.js";

function unsringifyConstants(Fr, o) {
    if ((typeof(o) == "string") && (/^[0-9]+$/.test(o) ))  {
        return Fr.e(o);
    } else if ((typeof(o) == "string") && (/^0x[0-9a-fA-F]+$/.test(o) ))  {
        return Fr.e(o);
    } else if (Array.isArray(o)) {
        return o.map(unsringifyConstants.bind(null, Fr));
    } else if (typeof o == "object") {
        if (o===null) return null;
        const res = {};
        const keys = Object.keys(o);
        keys.forEach( (k) => {
            res[k] = unsringifyConstants(Fr, o[k]);
        });
        return res;
    } else {
        return o;
    }
}

export default async function buildPoseidon() {
    const bn128 = await getCurveFromName("bn128", true);

    const F = bn128.Fr;

    // Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
    // Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
    const {C, M} = unsringifyConstants(F, poseidonConstants);

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    const N_ROUNDS_F = 8;
    const N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];

    const pow5 = a => F.mul(a, F.square(F.square(a, a)));

    function poseidon(inputs, initState, nOut) {
        assert(inputs.length > 0);
        assert(inputs.length <= N_ROUNDS_P.length);

        const t = inputs.length + 1;
        const nRoundsF = N_ROUNDS_F;
        const nRoundsP = N_ROUNDS_P[t - 2];

        if (initState) {
            initState = F.e(initState);
        } else {
            initState = F.zero;
        }
        nOut = nOut || 1;

        let state = [initState, ...inputs.map(a => F.e(a))];
        for (let r = 0; r < nRoundsF + nRoundsP; r++) {
            state = state.map((a, i) => F.add(a, C[t - 2][r * t + i]));

            if (r < nRoundsF / 2 || r >= nRoundsF / 2 + nRoundsP) {
                state = state.map(a => pow5(a));
            } else {
                state[0] = pow5(state[0]);
            }

            state = state.map((_, i) =>
                state.reduce((acc, a, j) => F.add(acc, F.mul(M[t - 2][i][j], a)), F.zero)
            );
        }
        if (nOut == 1) {
            return state[0]
        } else {
            return state.slice(0, nOut);
        }
    }

    poseidon.F = F;
    return poseidon;
}

// let poseidon = await buildPoseidon();
// const res1 = poseidon([1, 2, 3, 4]);
// console.log(poseidon.F.toString(res1, 16));

// let poseidon = await buildPoseidon();
// const res2 = poseidon([2, 2, 1, 2]);
// console.log(poseidon.F.toString(res2, 16));

// let poseidon = await buildPoseidon();
// const res3 = poseidon(["21353905736832881724403434788717165287411869115262791897948629296309025827272"]);
// console.log(res3);
// console.log(poseidon.F.toString(res3, 16));
let poseidon = await buildPoseidon();
const res3 = poseidon(["33353905736832881724403434788717165287411869115262791897948629296309025827233"]);
console.log(res3);
console.log(poseidon.F.toString(res3, 16));


// let poseidon = await buildPoseidon();
// const res1 = poseidon(["0x1ea6414205c5435946cbe5e4d1173f4b647d481b50e92f3166a209d7d1853f86",
// "0x1ea6414205c5435946cbe5e4d1173f4b647d481b50e92f3166a209d7d1853f87",
// "0x1ea6414205c5435946cbe5e4d1173f4b647d481b50e92f3166a209d7d1853f88",
// "0x1ea6414205c5435946cbe5e4d1173f4b647d481b50e92f3166a209d7d1853f89"]);
// console.log(poseidon.F.toString(res1, 16));

// var pk1s = [[[
//     "3206263855840730682",
//     "9975927634690586045"
//     ],
//     [
//     "17386009699530582858",
//     "15758004313402970226"
//     ],
//     [
//     "17582259918375165007",
//     "16905884769780094067"
//     ],
//     [
//     "14556386302160438524",
//     "15778416801092927012"
//     ]],
//     [
//         [ "1203612593502003649", "18251030406463011143" ],
//         [ "14029712340218102059", "15925426719904590980" ],
//         [ "14966161060974310615", "8562823132820424434" ],
//         [ "9328043236777212133", "16085754266872532303" ]
//       ]
      
// ]

// let poseidon = await buildPoseidon();

// var pk1s_arr = [];
// for (var i=0; i<pk1s.length; i++) {
//     for (var j=0; j<4; j++) {
//         pk1s_arr.push(pk1s[i][j][0]);
//         pk1s_arr.push(pk1s[i][j][1]);
//     } 
// }
// console.log(pk1s_arr);

// const res1 = poseidon(pk1s_arr);
// console.log(poseidon.F.toString(res1, 16));

// var rand = [[
//     "4264418248858902731",
//     "1577798531958286548",
//     "12070104388605992963",
//     "17679657645462206226"
//   ],
//   [
//     "4264418248858902731",
//     "1577798531958286548",
//     "12070104388605992963",
//     "17679657645462206226"
//   ]
// ]
    
//     let poseidon = await buildPoseidon();
    
//     var rand_arr = [];
//     for (var i=0; i<rand.length; i++) {
//         for (var j=0; j<4; j++) {
//             rand_arr.push(rand[i][j]);
//         } 
//     }
//     console.log(rand_arr);
    
//     const res1 = poseidon(rand_arr);
//     console.log(poseidon.F.toString(res1, 16));